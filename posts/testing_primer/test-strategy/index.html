<!DOCTYPE html>
<html lang="en-gb">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Jacek Bilski">

    
    
    

<title>Test Strategy • On Software Engineering</title>
<meta name="description" content="In our previous posts, we focused on why and how we write tests. In most of our projects, there will be many of those tests. In the last post about tests granularity, we additionally stated that there usually will be different kinds of tests, on different levels of granularity. That leads to our next topic: which kinds of tests do we need and what is the ideal mix of them?">
<meta name="keywords" content="tests, testing, automated testing, test strategy, software quality">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Test Strategy"/>
<meta name="twitter:description" content="In our previous posts, we focused on why and how we write tests. In most of our projects, there will be many of those tests. In the last post about tests granularity, we additionally stated that there usually will be different kinds of tests, on different levels of granularity. That leads to our next topic: which kinds of tests do we need and what is the ideal mix of them?"/>
<meta name="twitter:site" content="@jacek_bilski"/>

<meta property="og:title" content="Test Strategy" />
<meta property="og:description" content="In our previous posts, we focused on why and how we write tests. In most of our projects, there will be many of those tests. In the last post about tests granularity, we additionally stated that there usually will be different kinds of tests, on different levels of granularity. That leads to our next topic: which kinds of tests do we need and what is the ideal mix of them?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.bilski.tech/posts/testing_primer/test-strategy/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-07-05T00:00:00+00:00" />
<meta property="og:see_also" content="https://www.bilski.tech/posts/testing_primer/tests-organization-and-naming/" /><meta property="og:see_also" content="https://www.bilski.tech/posts/testing_primer/tests-granularity/" /><meta property="og:see_also" content="https://www.bilski.tech/posts/testing_primer/anatomy-of-a-good-test/" /><meta property="og:see_also" content="https://www.bilski.tech/posts/testing_primer/why-you-should-write-automated-tests/" />



    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.302e105633e7b74ff627e4a63c9fc0dc7446d15c60a7a4a2e12da987fdd9de0e.css" integrity="sha256-MC4QVjPnt0/2J&#43;SmPJ/A3HRG0Vxgp6Si4S2ph/3Z3g4=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://www.bilski.tech/">
        
          On Software Engineering
        
        </a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://www.bilski.tech/img/jacek.jpg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Jacek Bilski&#39;s thoughts about software engineering and how to improve it 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">On Software Engineering</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/random/">
						<span>Random Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/webcalc/">
						<span>WebCalc</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/testing_primer/">
						<span>Testing Primer</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/videos/">
						<span>Videos</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About Me</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/jacek_bilski" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="https://github.com/jacekbilski" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/jacek-bilski" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://www.xing.com/profile/Jacek_Bilski3" rel="me"><i class="fab fa-xing fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Test Strategy</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jul 5, 2021<br/>
    
    
    <i class="fas fa-user-edit"></i>
    
        Torsten Mandry, Theo Pack, Jacek Bilski
    
    <br/>
    
    
    
    
      
      
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/tests">tests</a>
           
      
          <a class="badge badge-tag" href="/tags/testing">testing</a>
           
      
          <a class="badge badge-tag" href="/tags/automated-testing">automated testing</a>
           
      
          <a class="badge badge-tag" href="/tags/test-strategy">test strategy</a>
           
      
          <a class="badge badge-tag" href="/tags/software-quality">software quality</a>
          
      
    
    
    <br/>
    
        <i class="fas fa-clock"></i> 14 min read
    
</div>


  </header>
  
  
  <div class="post">
    <p>Note, this post was originally published on <a href="https://www.innoq.com/en/blog/test-strategy/" target="_blank">INNOQ blog</a> together with <a href="https://torstenmandry.github.io/" target="_blank">Torsten Mandry</a> and <a href="https://furikuri.net/" target="_blank">Theo Pack</a>.</p>
<p>In our previous posts, we focused on why and how we write tests.
In most of our projects, there will be many of those tests.
In the last post about tests granularity, we additionally stated that there usually will be different kinds of tests, on different levels of granularity.
That leads to our next topic: which kinds of tests do we need and what is the ideal mix of them?</p>
<p>All posts in this series:</p>
<ul>
<li><a href="/posts/testing_primer/why-you-should-write-automated-tests/">Why You Should Write Automated Tests</a></li>
<li><a href="/posts/testing_primer/anatomy-of-a-good-test/">Anatomy of a Good Test</a></li>
<li><a href="/posts/testing_primer/tests-granularity/">Tests Granularity</a></li>
<li>This post: Test Strategy</li>
<li><a href="/posts/testing_primer/tests-organization-and-naming/">Tests Organization and Naming</a></li>
</ul>
<p>In a typical project, there are lots of automated tests.
We already showed some examples like <code>ShoppingCartTest</code> before.
This test is rather isolated.
It does provide us with some confidence, but only about a small part of the system.
We also wrote about different kinds of tests on different levels of granularity and isolation/integration.
In most projects having isolated tests isn’t sufficient.
We need at least some higher-level tests to be confident about the quality and correctness of the overall system.
This leads to some questions:</p>
<ul>
<li>Which kinds of tests do we need?</li>
<li>What is the responsibility of each kind of test, what is out of their scope?</li>
<li>How do we combine those different kinds of tests to gain the most confidence?</li>
</ul>
<p>Those questions - and probably some more - should be answered consciously for each project.
The decisions - as almost every project decision - should be driven by the individual requirements of the project.
The decisions are a crucial part of the test strategy for the project.
But what exactly is a test strategy?
It is difficult to find a single definition of the term &ldquo;test strategy&rdquo; (see for example the definitions in <a href="https://en.wikipedia.org/wiki/Test_strategy" target="_blank">Wikipedia</a> or by the <a href="https://istqb-glossary.page/test-strategy/" target="_blank">ISTQB</a>).
Yet, at its core, the definitions seem to have the same goal, &ldquo;How do we test our system to ensure that the requirements are met?&rdquo;.
Part of a test strategy can also be the description of roles and responsibilities, a test plan, or the test environment.
However, we will not go into these aspects here.</p>
<h3 id="test-types">Test Types</h3>
<p>We do not write automated tests just for the sake of having them.
We write them, mainly, to gain confidence about the correct behaviour of our code.
“Correct”, though, can mean slightly different things, depending on an aspect.
Also, each aspect might require a different type of test.</p>
<p>In our <a href="https://www.innoq.com/en/blog/tests-granularity/" target="_blank">Tests Granularity</a> post, we already talked about some different kinds of tests that can be identified on the isolation-integration-axis of the test pyramid.
In most of the projects we have seen so far this was the main aspect that identified different kinds of tests.
But, depending on the context of our project, there might be other aspects.</p>
<p>When it comes to the correctness of the system, we’re not limited to example-based tests.
Those are the tests we see most commonly, which verify that for a given input our system returns an expected output or transitions to a given state.
We could also decide to test parts or the whole system using <a href="https://dev.to/jdsteinhauser/intro-to-property-based-testing-2cj8" target="_blank">property-based tests</a>.</p>
<p>If performance is a critical aspect of our project we might want to have some performance tests in addition.
We might also need some automated stress tests to make sure our system can handle the expected amount of requests.
The same goes for security.
Maybe we need some automated (or at least regularly executed) penetration tests of our system.
In highly regulated project contexts there may also be some other kinds of tests that we have to include in your test strategy.</p>
<p>Generally speaking, the necessary types of tests and their number depend on the quality requirements of our system.</p>
<p>One other thing that has a huge impact on our test requirements is the release and deployment strategy of our project.
If our system is deployed automatically after each commit (continuous deployment) we completely rely on our automated tests to detect any (critical) bugs.
If, on the other hand, our system is released and deployed on a manual basis (at least to production), it might be OK to keep our automated tests a little more relaxed.
At least, if we can ensure that the resulting gap of confidence is filled by a comprehensive set of manual tests that are executed before the deployment.</p>
<p>That brings us to another point in selecting the necessary kinds of tests for our overall test strategy: not all of those tests have to be automated.
It’s perfectly fine to decide that testing some aspects of our system in an automated way is too difficult or too expensive, and they will be tested manually, at least for the start.
We could even decide that other aspects are just nice-to-have and not important for the overall functionality of our system and so will not be tested at all.
For all those decisions it’s important to make them consciously, based on the project context (maybe some assumptions).
Ideally, they’re all documented in the test strategy.</p>
<p>Sticking to our online shop example, we might decide that we need the following kinds of tests to be confident about the correctness and quality of our system:</p>
<ul>
<li>end-2-end tests, testing the shop as a whole (via the UI)</li>
<li>more detailed tests of the main components of the shop (e.g. shopping cart, catalogue, search, …)</li>
<li>isolated test of single classes/methods on demand (if they help in addition to the previous ones)</li>
<li>performance tests of the main click paths (especially catalogue, shopping cart, checkout)</li>
<li>design, look-and-feel, accessibility will be tested manually</li>
<li>penetration tests will be done once before the go-live of the shop, then regularly every year</li>
</ul>
<h3 id="responsibilities-and-composition">Responsibilities and Composition</h3>
<p>As we wrote before (<a href="https://www.innoq.com/en/blog/why-you-should-write-automated-tests/" target="_blank">Why You Should Write Automated Tests</a>), writing and maintaining tests does not come for free.
Writing them takes time.
Executing them takes time.
Maintaining them takes even more time, respecting the fact that they usually stay in the project and have to be kept in sync (directly or indirectly) for a long time.</p>
<p>It bears repeating, test strategy is about getting as much confidence as possible/necessary about the behaviour of the system with reasonable effort.
After implementing the strategy we should feel safe when releasing the system after all our tests succeeded.</p>
<p>So, the goal is not to write as many tests as possible.
Instead, we want to write just as many tests as necessary.
This means that, in an optimal set of tests, usually called a test suite, every single test should have its own, distinct focus.
The tests should be MECE: mutually exclusive, collectively exhaustive.
On one hand, they should cover all important aspects of the system, on the other, they should not overlap.</p>
<p>As you might have experienced by yourself, this kind of optimal test suite is very hard to achieve.
Especially keeping the tests mutually exclusive becomes even harder, if not impossible if we combine tests of different granularity.
Although, we should still try to get as close as possible to this goal to gain the most benefit from our tests spending the least effort.</p>
<p>To be able to do this we need to be clear about the responsibility of each kind of test.
Of course, this goes hand in hand with the decision on which kind of tests we need.
If we are missing another kind of test to be confident, this automatically means that there’s at least one aspect that is not yet covered by all the tests we already have.
So the responsibility of the additional kind of test is obviously to cover exactly this aspect.
It’s also possible to explicitly exclude some aspects from the responsibility of one kind of test and move it to another one.</p>
<p>Once we are clear about the responsibilities it’s important to keep these in mind when writing the different tests.
A test should focus on its own responsibility and, if possible, ignore everything else.
If we do not stick to this rule, we will end up testing one aspect multiple times in different tests, and usually in different ways.</p>
<p>Let’s go back to our example and have a look at the responsibilities of the different kinds of tests to get this a little clearer.</p>
<p>We decided to have some tests of the main components of the shop.
They should ensure that each of these components works as expected.
A component will probably contain several smaller units as well as some infrastructure (database, search index, http, ui, &hellip;).
So those tests will need some level of integration which will increase their complexity, development effort, execution time, and so on.</p>
<p>There will probably be some details in the implementation of each component that can be tested much easier with some more isolated tests.
So we decided to have those tests as well for those details.
This of course means that those details should then be ignored by the higher-level component tests.
For example, the component test of the shopping cart might test that the subtotal amount is calculated if a product is added to the cart.
Some detailed isolation tests of the calculation function might ensure that the result is correct, even if the product was added with quantity 2, 0, -1 or NaN.</p>
<p>On the other hand, knowing that each component works well in isolation does not feel confident enough for the overall shop.
So we want to have some end-2-end tests to ensure that the components properly play together and the main use cases are working.
Those end-2-end tests should try to ignore the details which are already covered by the previous tests (e.g. ensuring that the shopping cart amounts are calculated correctly) but focus on the interaction between those components instead (e.g. adding a product from the catalogue to the shopping cart).
To verify this functionality those tests do not need to care about the details of the product or the concrete amounts of the shopping cart.
It should be sufficient to verify that, after adding the product, the shopping cart contains one item.
Maybe it’s necessary to ensure that it’s the expected item, but this should be done as superficially as possible, ignoring the details.</p>
<p>Combining the different kinds of tests in this way, they form a kind of layered test architecture, where each layer focuses on its own responsibility and relies on and trusts the layers below to care about the more detailed stuff.</p>
<h3 id="tooling-and-implementation">Tooling and Implementation</h3>
<p>Apart from what we should test and how to combine those tests, our test strategy should also say something about the “how”.
Even if we correctly identify and create the suites and tests themselves, we might choose better or worse ways or tools to implement them.
For example, for performance testing, we could write the tests using JUnit only, but probably choosing a tool specifically designed for this job (like JMeter) would be a better idea.
It’s also a good idea to use those tools consistently.
If we need to write performance tests for several different components, writing them, in the same way, using the same tool will help us keep the overall complexity of our tests at a reasonable level.
In this case, the test strategy is the right place to describe how performance testing is handled in our project.</p>
<p>Another aspect of the tests is how to write the test cases.
One choice could be to completely specify/write them in the code.
On one hand, this would make the life of the developers easier, there would be no need to learn new tools or use different languages for different purposes.
On the other hand, this could prevent non-developers from writing tests or even reading and understanding those tests.
If we would choose to write the test cases in Cucumber, JBehave, or a similar tool, we would be able to specify the test cases in plain English (or some other language).
That could enable us to automatically generate more readable test reports.
Although, it would probably mean more complexity and effort, because of the additional tool (layer).</p>
<p>One more thing to consider is the testing environment.
Some systems might require some hardware to be tested on (think firmware).
Testing those systems on a regular PC or a server cannot be done at all or only with a limited scope.
In that case, this environment might heavily affect how we can test our software.
We might also decide that we will create separate test suites, one for testing locally, and one for testing in this special testing environment.
On one hand, we would be able to run some tests fast and get quick, although limited, feedback.
Executing this other test suite requiring special hardware could be done every night.
Feedback would be far better, although delayed.
On the other hand, that would probably require some tests to overlap, would definitely need more effort, but, depending on the context, could still be a good idea.</p>
<h3 id="scheduling">Scheduling</h3>
<p>Apart from deciding upon what we need to test, which tools we will use and how we write the tests, we also need to agree on when to run each kind of test.
The easiest answer, all of them as often as possible, is usually not realistic.
As long as the system we’re working on is relatively small we could do that.
But sooner or later running all of our automated tests will simply take too much time to execute them every few seconds or minutes.
And that will happen even though we were careful about having our tests run fast (see our <a href="https://www.innoq.com/en/blog/tests-granularity/" target="_blank">Tests Granularity</a> post).</p>
<p>Our testing strategy might for example say that we need to run all of our automated tests on every push to the repository.
Our CI/CD tool will then try to build and test the whole application.
If the tests take a few minutes, it shouldn’t be a big problem.
It is also common for certain types of tests (e.g. unit tests) to be run locally on the developer&rsquo;s computer regularly.
For this to be possible without problems, the test strategy might say that certain test types must be executable locally without side effects on other systems.</p>
<p>Still, that might not be enough.
Let’s assume we have one test suite dedicated to load or stress testing our system.
Such a suite might need to run for quite some time to allow the system to warm up the caches.
If such a suite takes an hour to complete, do we really want to execute it on every push to the repository? It would probably be enough to run such a suite before merging into the main branch.
We could also decide to run it every night on each branch, just to notify the teams if they’ve impacted the performance of the system negatively early on.</p>
<p>Another aspect to consider would be cost.
Even automated tests can be expensive to execute.
Load testing might require a lot of infrastructure.
Even if we use cloud services, we might find out that spinning up the whole setup several times per day leads to considerable expenses.
A similar problem arises when we need something special for our tests, like dedicated hardware (again, think about developing firmware).
We might only have so much of it, and there might be several teams competing for access to this hardware.
In such cases, the test strategy might prescribe how to efficiently use available resources and still achieve enough confidence.</p>
<p>Also, don’t forget that not all tests need to be automated.
Those tests that are not automated would need to be executed manually, probably shortly before the release and deployment of our system.
Similar to hardware limitations, here we also need to take into consideration how many people would be able to execute those manual tests, how much time those tests take, what other responsibilities those people have, etc.
We might find out that we will need to hire more testers to satisfy the testing goal defined in the testing strategy.</p>
<p>Running the tests too often might create too many costs or require too much effort to justify the results.
On the other hand, running the tests too rarely might lead to a situation where we wouldn’t know about a problem we’ve introduced for too long.
Once we notice something is wrong, it might not be that easy and cheap to find and fix the problem.
The test strategy needs to find a balance.</p>
<h3 id="conclusion">Conclusion</h3>
<p>A test strategy is a very important document for each reasonably big project.
It defines which aspects of our system need to be tested, how we address those aspects using different kinds of tests, and how often we run those tests.
Its main purpose is to help everyone involved understand how we ensure that in the end, our system will be of good quality.</p>
<p>Many thanks to Joachim Praetorius for his feedback and suggestions to improve this post.</p>

  </div>
  


  

  
    
        <script src="https://utteranc.es/client.js"
        repo="jacekbilski/jacekbilski.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
    


</article>


        </div>
        
    

<script defer src="https://use.fontawesome.com/releases/v5.12.1/js/all.js" integrity="sha384-ZbbbT1gw3joYkKRqh0kWyRp32UAvdqkpbLedQJSlnI8iLQcFVxaGyrOgOJiDQTTR" crossorigin="anonymous"></script>


    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    



    



    </body>
</html>
