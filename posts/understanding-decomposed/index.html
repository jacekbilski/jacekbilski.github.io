<!DOCTYPE html>
<html lang="en-gb">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Jacek Bilski">
<meta name="generator" content="Hugo 0.80.0" />

    
    
    

<title>Understanding decomposed ‚Ä¢ On Software Engineering</title>
<meta name="description" content="I think we can all agree that having our codebases more readable and understandable would make our lives much easier. In this post, I&#39;m trying to point out at least a few ideas that influence understanding.">
<meta name="keywords" content="code readability, programming, simplicity, understanding">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding decomposed"/>
<meta name="twitter:description" content="I think we can all agree that having our codebases more readable and understandable would make our lives much easier. In this post, I&#39;m trying to point out at least a few ideas that influence understanding."/>
<meta name="twitter:site" content="@jacek_bilski"/>

<meta property="og:title" content="Understanding decomposed" />
<meta property="og:description" content="I think we can all agree that having our codebases more readable and understandable would make our lives much easier. In this post, I&#39;m trying to point out at least a few ideas that influence understanding." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.bilski.tech/posts/understanding-decomposed/" />
<meta property="article:published_time" content="2018-06-22T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-06-22T00:00:00+00:00" />


    






<link rel="stylesheet" href="/scss/hyde-hyde.1edfcb2970975b6b5c3405c71d8ce6eb1bb64a550a9c090be52e9bb0235389a5.css" integrity="sha256-Ht/LKXCXW2tcNAXHHYzm6xu2SlUKnAkL5S6bsCNTiaU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://www.bilski.tech/">
        
          On Software Engineering
        
        </a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://www.bilski.tech/img/jacek.jpg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Jacek Bilski&#39;s thoughts about software engineering and how to improve it 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">On Software Engineering</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/various/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/webcalc/">
						<span>WebCalc</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/videos/">
						<span>Videos</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About Me</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/jacek_bilski" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="https://github.com/jacekbilski" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/jacek-bilski" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://www.xing.com/profile/Jacek_Bilski3" rel="me"><i class="fab fa-xing fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ‚ù§Ô∏è <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Understanding decomposed</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jun 22, 2018<br/>
    
    <i class="fas fa-user-edit"></i> Jacek Bilski
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/code-readability">code readability</a>
           
      
          <a class="badge badge-tag" href="/tags/programming">programming</a>
           
      
          <a class="badge badge-tag" href="/tags/simplicity">simplicity</a>
           
      
          <a class="badge badge-tag" href="/tags/understanding">understanding</a>
          
      
    
    
    <br/>
    
        <i class="fas fa-clock"></i> 8 min read
    
</div>


  </header>
  
  
  <div class="post">
    <p>I <a href="/posts/supporting-understanding-with-simplicity/">previously wrote</a> about simplicity and how it helps to understand software code. In that post, I already mentioned the use of concepts like set theory. I‚Äôd like to expand on this and show how to boost readability of code.</p>
<p>Despite what people might think, our main purpose as developers is not writing software, but solving problems. A code is just a means, not the goal. Nobody demands software just for the sake of it from a developer. Applications need to solve whatever problems our customers need to have solved. This point of view on why we are here also changes what software is. It ceases to be a merely different formulation of a solution that is specified somewhere, it <!-- raw HTML omitted -->is<!-- raw HTML omitted --> the solution. But this requires us to think differently about what it is we are doing, and how we‚Äôre doing it.</p>
<p>The code is the ultimate truth, as they say. After all, this is what is executed in production, not some written specification, diagrams, JIRA tickets, or the ideas we‚Äôre keeping in our heads. The problem is, that if the code is the solution, then there are a few groups of people that need to understand it. The first one is developers, after all, we‚Äôre closest to it, we‚Äôre writing it, it‚Äôs our bread and butter, our life. The second group is the stakeholders or customers, who are defining how the systems should behave. Maybe some other groups, like operations, are also interested to understand how the system will behave, or with what other systems it interacts.</p>
<p>Let‚Äôs do a small experiment. Below is a piece of code. Please take a look at this and try to name the algorithm that is implemented here.</p>
<pre><code>int n = arr.length;
int temp = 0;
for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 1; j &amp;lt; (n - i); j++) {
        if (arr[j - 1] &amp;gt; arr[j]) {
            temp = arr[j - 1];
            arr[j - 1] = arr[j];
            arr[j] = temp;
        }
    }
}
</code></pre>
<p>It‚Äôs bubble sort, but it probably took you a few seconds to find out. If I just wrote <code>bubbleSort(arr)</code>, you‚Äôd know immediately what it does, how it&rsquo;s done, and a few other properties of the algorithm, like its terrible performance for bigger arrays. The only trick I used was to name this piece of code, and this name refers to something you already know. If you don‚Äôt, it‚Äôs very easy to find out.</p>
<p>My point is, that by using known concepts we can make the code shorter and more understandable. This piece of code is 11 lines long, merely calling a function takes just one line. Of course, those 11 lines need to be written somewhere, but we can hide them deeper in our code, outside of the part where the ‚Äúbusiness logic‚Äù lives.</p>
<p>Those concepts can be anything. I mentioned a pretty obvious one, making elements of a collection ordered in some way, it‚Äôs called sorting, everybody knows it. Another example could be set theory with such operations like intersection, set difference or Cartesian product. After all, our applications are about data processing, and it&rsquo;s never about one &ldquo;data&rdquo;. Yet another example of such a concept could be design patterns, which are re-usable solutions to well-understood problems. Once a developer hears about, for instance, a decorator pattern, he or she should immediately understand what to expect.</p>
<p>There&rsquo;s a really nice tweet from Mario Fusco:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Imperative vs. Functional - Separation of Concerns <a href="http://t.co/G2cC6iBkDJ">pic.twitter.com/G2cC6iBkDJ</a></p>&mdash; Mario Fusco üá™üá∫ (@mariofusco) <a href="https://twitter.com/mariofusco/status/571999216039542784?ref_src=twsrc%5Etfw">March 1, 2015</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>Although it&rsquo;s a bit biased towards the functional way, and imperative code can definitely be improved (see discussion below the tweet), it clearly shows some benefits of using pre-existing ideas, monadic function composition in this case. Knowledge of such a technique, coming from the functional world and now being more and more adopted in the OOP world, enables not only a better separation of concerns but also more descriptive code. I&rsquo;d argue, that the functional code says more what it does, imperative code is more about how to achieve it. Because of that, the functional code is more readable and understandable; it conveys intention. And it&rsquo;s just an example, I&rsquo;m not trying to say, that functional programming is always or usually better than an object-oriented or procedural approach. But because in the functional world certain mathematical abstracts are much more present or natural, also the code can be far easier expressed in terms of those abstractions.</p>
<p>Why is it so important to go for known things? Because they tend to &ldquo;disappear&rdquo; from the sight and leave more space for other, usually more important matters. Once we can refer to some external knowledge, our brains don&rsquo;t need to worry about that part any more. If I know what &ldquo;intersection&rdquo; from set theory means, then understanding <code>a.intersect(b);</code> is trivial. I don&rsquo;t even see the dot, the semicolon and the brackets any more. If I wrote <code>a.commonElements(b);</code>, I&rsquo;d probably force myself and others to think about or find out in the code what is meant by <code>commonElements</code>. It would be one more thing to keep in my head, in my <a href="https://en.wikipedia.org/wiki/Working_memory" target="_blank">working memory</a>.</p>
<p>This memory is however very small. It can keep approximately 7 &ldquo;things&rdquo; at the same time. Once we exceed our own limits, we&rsquo;re losing the whole picture, we cannot comprehend the whole problem as one any more (by the way, this is also the moment where bugs start to creep into our code). If we refer to something we already know, then those concepts don&rsquo;t need to &ldquo;take up space&rdquo; in our working memory, so it&rsquo;s easier and faster to reason about the code.</p>
<p>A different aspect of understanding has to do with the language we&rsquo;re using. The software we&rsquo;re writing is a type of mental model. Those models try to reflect real life as much as possible or necessary. They can also have theories built around them helping us deal with real life or decide what to do. Those models and our software should be as close as possible to real life models to reduce friction between them. Any differences are bug breeding grounds, and very time consuming to work with. Every time we see parts of the code, that show inconsistencies, we need to think about whether the code indeed reflects reality, or whether it looks like it looks because we were unable to express reality in a better way.</p>
<p>This whole idea plays very well with ubiquitous language, an integral part of <a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank">Domain Driven Design</a>. It states, that there should be only one common language used to talk about the problem we&rsquo;re trying to solve, no matter who&rsquo;s talking to whom, developers, testers, business people, and also in the code. It makes sense; why would we want to &ldquo;translate&rdquo; between code, documentation and spoken language, after all, we&rsquo;re talking about the same things. In such translations, we&rsquo;d be losing important details, and it also takes time and effort.</p>
<p>If such a language doesn&rsquo;t exist yet, we should create it. Or rather, like agile or extreme programming proposes, use metaphors. That way, although there&rsquo;s no language specific to the kind of problem we&rsquo;re trying to solve, there is a similar concept from which we then can borrow. This will also help in communication between people; instead of describing terms every time we need to, or giving them some artificial names, we can use terms from this other domain. Their power is, that they already have a meaning in the context we&rsquo;re interested in. It will also greatly speed up bringing new people to the project or talking about the project outside.</p>
<p>Code written using ubiquitous language or metaphors will also reveal its intent much quicker. It&rsquo;s a very important property of a <a href="http://wiki.c2.com/?XpSimplicityRules" target="_blank">simple design</a>. Such design leads to quicker software development and only implementing what is actually needed. If we can split our big problem into smaller ones and properly separate the concerns, we have higher chances of being able to use ubiquitous language directly in the code, thus making it more understandable. Our code should be talking more about the actual problem it&rsquo;s trying to solve, than any technical solution it uses, like libraries, frameworks or databases.</p>
<p>This also might have the additional benefit of not having to write code at all. Chances are, that for any problem that is not core and unique to our business, someone already solved it, and there is a library available. If we use this library, we&rsquo;ll save ourselves the time writing and maintaining it, and we&rsquo;ll be able to focus more on important matters. It will, again, make the code more understandable, because there will be less code to understand. We should also remember, that our task is to solve problems, not to write code, and we should only work on something that differentiates our companies from the competition. This is where profit is generated, the commodity code has already been written, all companies can get it, so there&rsquo;s no real advantage here.</p>
<p>As you can clearly see by the sheer amount of topics and concepts I mentioned in this post, it&rsquo;s not so easy to keep our code understandable. And I didn&rsquo;t even mention all of them. It also means that we can make our code difficult to read in so many ways. But I believe that it is in our common goal to make our code more readable and understandable. This not only makes working with such code easier but helps us to deliver value faster.</p>
<p>Happy coding!</p>
<p>Note, this article was originally posted on <a href="https://www.innoq.com/en/blog/understanding-decomposed/" target="_blank">INNOQ blog</a>.</p>

  </div>
  


  

  
    
        <script src="https://utteranc.es/client.js"
        repo="jacekbilski/jacekbilski.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
    


</article>


        </div>
        
    

<script defer src="https://use.fontawesome.com/releases/v5.12.1/js/all.js" integrity="sha384-ZbbbT1gw3joYkKRqh0kWyRp32UAvdqkpbLedQJSlnI8iLQcFVxaGyrOgOJiDQTTR" crossorigin="anonymous"></script>




    



    </body>
</html>
