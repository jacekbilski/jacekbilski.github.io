<!DOCTYPE html>
<html lang="en-gb">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="author" content="Jacek Bilski">
<meta name="generator" content="Hugo 0.54.0" />

    
    
    

<title>Supporting understanding with simplicity • On Software Engineering</title>
<meta name="description" content="Some time ago, my colleague Joy Clark wrote about simplicity. I&rsquo;ve also approached this topic once before. I&rsquo;d like to follow up on both articles and show how simplicity can boost our understanding of software. I will also propose that we look at other disciplines to see if and how simplicity affects them. Maybe we can benefit from their experience.
What&rsquo;s all the fuss about? Why do we even talk about simplicity?">
<meta name="keywords" content="code readability, complexity, programming, simplicity, understanding">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Supporting understanding with simplicity"/>
<meta name="twitter:description" content="Some time ago, my colleague Joy Clark wrote about simplicity. I&rsquo;ve also approached this topic once before. I&rsquo;d like to follow up on both articles and show how simplicity can boost our understanding of software. I will also propose that we look at other disciplines to see if and how simplicity affects them. Maybe we can benefit from their experience.
What&rsquo;s all the fuss about? Why do we even talk about simplicity?"/>
<meta name="twitter:site" content="@jacek_bilski"/>

<meta property="og:title" content="Supporting understanding with simplicity" />
<meta property="og:description" content="Some time ago, my colleague Joy Clark wrote about simplicity. I&rsquo;ve also approached this topic once before. I&rsquo;d like to follow up on both articles and show how simplicity can boost our understanding of software. I will also propose that we look at other disciplines to see if and how simplicity affects them. Maybe we can benefit from their experience.
What&rsquo;s all the fuss about? Why do we even talk about simplicity?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.bilski.tech/posts/supporting-understanding-with-simplicity/" />
<meta property="article:published_time" content="2018-06-15T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-06-15T00:00:00&#43;00:00"/>


    






<link rel="stylesheet" href="/scss/hyde-hyde.d8e474f8dcee7b234bc8afe1479c3b44440642d23eebbb8b4977250a46484d42.css" integrity="sha256-2OR0&#43;NzueyNLyK/hR5w7REQGQtI&#43;67uLSXclCkZITUI=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://www.bilski.tech/">On Software Engineering</a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://www.bilski.tech/img/jacek.jpg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Jacek Bilski&#39;s thoughts about software engineering and how to improve it 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">On Software Engineering</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About Me</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/jacek_bilski" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://github.com/jacekbilski" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://linkedin.com/in/jacek-bilski" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="https://www.xing.com/profile/Jacek_Bilski3" rel="me"><i class="fab fa-xing fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>Supporting understanding with simplicity</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jun 15, 2018<br/>
    
    <i class="fas fa-user-edit"></i> Jacek Bilski
    
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/code-readability">code readability</a>
           
      
          <a class="badge badge-tag" href="/tags/complexity">complexity</a>
           
      
          <a class="badge badge-tag" href="/tags/programming">programming</a>
           
      
          <a class="badge badge-tag" href="/tags/simplicity">simplicity</a>
           
      
          <a class="badge badge-tag" href="/tags/understanding">understanding</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 9 min read
</div>


  </header>
  
  
  <div class="post">
    

<p>Some time ago, my colleague Joy Clark <a href="https://www.innoq.com/de/blog/simplicity-fighting-complexity/" target="_blank">wrote about simplicity</a>. I&rsquo;ve also <a href="/posts/what-do-i-believe-in/" target="_blank">approached this topic</a> once before. I&rsquo;d like to follow up on both articles and show how simplicity can boost our understanding of software. I will also propose that we look at other disciplines to see if and how simplicity affects them. Maybe we can benefit from their experience.</p>

<h3 id="what-s-all-the-fuss-about">What&rsquo;s all the fuss about?</h3>

<p>Why do we even talk about simplicity? Why is it such a hot topic? Why is nobody praising complexity? Why do things like the <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS principle</a> exist? As it turns out, keeping things simple has some profound effects. In science, the <a href="https://en.wikipedia.org/wiki/Occam's_razor" target="_blank">Occam&rsquo;s razor</a> principle has been commonly used for a few hundred years. In short, it proposes that, if there are two or more hypotheses to choose from, the one with the fewest assumptions should be selected. Obviously, the &ldquo;razor&rdquo; is not a law, it cannot be proven, it&rsquo;s just a heuristics. The most interesting thing about it is the reasoning behind it. It states that the simplest hypothesis should be selected because it&rsquo;s the easiest to test or falsify. If we apply this principle to software engineering, we could say that we should prefer simpler solutions, because it&rsquo;s easier to find defects or prove the solution to be correct. Indeed, it feels intuitive. We could also reverse it and say that if we&rsquo;re having trouble while writing tests, it&rsquo;s probably because our solution is not as simple as it could be. But remember, it&rsquo;s only a heuristics, it does not necessarily need to be true. Maybe the problem you&rsquo;re trying to solve is indeed complex and your solution cannot be simplified. Einstein is <a href="https://quoteinvestigator.com/2011/05/13/einstein-simple/" target="_blank">credited with saying</a> &ldquo;Everything should be kept as simple as possible, but not simpler&rdquo;, maybe that&rsquo;s your case.</p>

<h3 id="what-does-simple-look-like">What does &ldquo;simple&rdquo; look like?</h3>

<p>But what is &ldquo;simple&rdquo;? How can we tell if something is simple, or select the simpler solution out of two? By definition, &ldquo;simple&rdquo; means &ldquo;having or composed of only one thing, element, or part&rdquo; (by <a href="https://www.wordnik.com/words/simple" target="_blank">Wordnik</a>), &ldquo;free of secondary complications, unmixed&rdquo; (by <a href="https://www.merriam-webster.com/dictionary/simple" target="_blank">Merriam-Webster</a>) or &ldquo;having few parts or features; not complicated or elaborate&rdquo; (by <a href="https://www.thefreedictionary.com/simple" target="_blank">The Free Dictionary</a>). The meaning is similar to what Rich Hickey proposes in his video <a href="https://www.infoq.com/presentations/Simple-Made-Easy" target="_blank">&ldquo;simple made easy&rdquo;</a> (it&rsquo;s one of those I strongly recommend watching). So &ldquo;simple&rdquo; is about cardinality, the less the simpler. It also plays very well with the idea of cognitive load. The human brain is said to be able to process only a few items at the same time. The more different concepts &ndash; like variables or state &ndash; influence any given piece of code, the less simple it is. As the number of moving parts increases, we need to use more energy and concentrate harder to reason about and change the code, so it takes more time and it&rsquo;s easier to make a mistake.</p>

<h3 id="how-simple-works">How &ldquo;simple&rdquo; works</h3>

<p>No wonder, then, that there exist so many principles suggesting to reduce the number of concepts present or affecting a particular piece of code, starting with <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" target="_blank">high cohesion</a> and <a href="https://en.wikipedia.org/wiki/Loose_coupling" target="_blank">low coupling</a>, through <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank">single responsibility principle</a> and <a href="https://en.wikipedia.org/wiki/Worse_is_better" target="_blank">worse is better</a>, all the way to <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank">TDD</a>. TDD is actually a very interesting example of how simplicity can help us on many different levels. It was developed as a technique that helps us focus on a single thing: the feature to implement. But not only are we avoiding the violation of the <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank">YAGNI principle</a>, it also has an additional psychological effect. Every single step focuses on a different aspect, so it frees us from thinking about too many things at the same time. When writing a test that fails, we don&rsquo;t need to think about the implementation. The only important thing is: what am I expecting the system to do. When making a test pass, we focus on just that, doing the simplest thing that will make the test green (and not make any other red). At this time, we don&rsquo;t need to worry about, for example, code quality, coding conventions, etc. We can worry about that in the refactoring step, but then the tests we wrote so far free us from thinking about functionality.</p>

<h3 id="is-it-easy">Is it easy?</h3>

<p>And again, it feels intuitive: fewer things at the same time are easier to handle, not only in software development. There&rsquo;s a reason why it&rsquo;s forbidden to drive a car and use a mobile phone at the same time. Of course, we can get better and be able to &ldquo;juggle&rdquo; more items at the same time, but there will always be a toll to pay and the limits can&rsquo;t be pushed indefinitely. You can surely recall a time when coding something was really difficult because you didn&rsquo;t know the API nor the syntax nor common pitfalls; your programs were buggy and crashed often. Because everything was new, it took an enormous amount of energy and focus to put a few things together. Now, as you&rsquo;re already familiar with your tools, standard library, etc., all those basic problems seem to disappear and leave you to focus on your actual problems. But that is only because it&rsquo;s getting easier for you to write code, it has nothing to do with how simple your language or tools are. They may be complicated, but after some practice, they become easy. Indeed, <a href="https://www.wordnik.com/words/easy" target="_blank">Wordink</a> defines easy as &ldquo;Capable of being accomplished or acquired with ease; posing no difficulty: an easy victory; an easy problem&rdquo;.</p>

<h3 id="it-s-a-trap">It&rsquo;s a trap!</h3>

<p>Making things easy might seem like a good idea. If you know the tool that can help you solve a problem at hand, you&rsquo;ll be done fast and probably without any major issues. The catch is: not everyone knows the tool. If a new developer joins the team they might have a hard time understanding what you did. They would need to familiarize themselves with the tool first before they can deep dive into your solution. Easy is subjective, simple is objective. Making things easier will always be making them easier for you or your current team, not for everybody. Making things simpler, on the other hand, will be making them simpler for everyone. Of course, simple doesn&rsquo;t automatically make things easy, it might still be complicated (though not complex). For example, this &ldquo;simple&rdquo; could mean, that the code implements some quite sophisticated algorithm, which is difficult to understand by itself, but it&rsquo;s free of anything that is not necessary to solve the problem, such as usage of Spring or Hibernate.</p>

<h3 id="understanding">Understanding</h3>

<p>But even if all those multiple things coupled together are easy for you, working with such code will not be easy. You&rsquo;d constantly need to switch contexts in your head while reading the code, each time focusing on a different concept. This not only takes time but also leads to all kinds of problems. The most important one is that you cannot easily understand the logic. There&rsquo;s no way to be able to see only the code you want to see, for example, business logic. There is a constant noise, code that does something else, not related to what interests you at the moment. Once you cannot understand what your application is doing and why it is doing it, you will introduce bugs and deliver features that do not fully match the requirements. Only if you can fully understand what is currently happening in the code, you will be able to change it in a predictable way and be aware of all the consequences of your changes. Such an understanding cannot be replaced by, for example, the presence of a test suite. This can only verify that you&rsquo;re not breaking current behaviour (covered by tests, that is). Simple code, containing just one concept, makes changes to the code much easier. The scope is limited and even if you are introducing issues, they&rsquo;ll be easy to find.</p>

<h3 id="the-power-of-simplicity">The power of simplicity</h3>

<p>Simplicity has also a different effect that we might want to pursue: elegance. It&rsquo;s this feeling, when you&rsquo;re looking at your solution, that you&rsquo;ve done the job right. The code is exactly to the point, does what it needs to do, it doesn&rsquo;t do more than that, it&rsquo;s efficient, succinct, you just look at it and know what it does, you cannot really improve it. Antoine de Saint Exupéry once said that &ldquo;It seems that perfection is reached not when there is nothing left to add, but when there is nothing left to take away&rdquo;. Also, mathematicians and physicists are looking for &ldquo;elegant&rdquo; solutions and theories. They&rsquo;ve learned over the centuries, that if their solution is not elegant enough, it probably can be improved as it most likely is not complete yet. That is not to say that it&rsquo;s wrong. It&rsquo;s just that it&rsquo;s not touching the very core of the problem yet, it might be just a step towards &ldquo;the&rdquo; solution. This can be very well seen in a pursuit of the <a href="https://en.wikipedia.org/wiki/Grand_Unified_Theory" target="_blank">Grand Unified Theory</a> in particle physics, where scientists know which parts need to be improved, just by looking at the pieces of the <a href="https://en.wikipedia.org/wiki/Standard_Model" target="_blank">Standard Model</a> that are not elegant enough. It goes very well with, already mentioned, Occam&rsquo;s razor, the more elegant, the more simple, the easier to falsify. So maybe it should also be a sign for us, that, whenever we see a not-so-elegant code, we&rsquo;re probably not solving the problem the simplest way possible.</p>

<h3 id="easy-is-not-evil">Easy is not evil</h3>

<p>Having said all that, I want to clarify, that &ldquo;easy&rdquo; is not a bad thing, it&rsquo;s not contradicting &ldquo;simple&rdquo; by definition &ndash; they can support each other very well. If &ldquo;simple&rdquo; is &ldquo;easy&rdquo; for you, even better, strive for it! Just make sure, that when you&rsquo;re trying to improve things, try to first make them simple. Once concerns are separated from one another, you can learn and familiarize yourself with those, which are not easy for you yet –– the same will be possible for all other people working with your code. It will be also possible for you and your team to announce that your code is assuming knowledge of, for example, set theory. When a new developer joins the team and they don&rsquo;t know some pieces yet, they can start working on those concerns they already know and, in parallel, learn the pieces they are not familiar with just yet. And even if they needed to go directly for the difficult parts of the system, they would at least be struggling with one problem only. So please, keep it simple.</p>

<p>Note, this article was originally posted on <a href="https://www.innoq.com/en/blog/understanding-through-simplicity/" target="_blank">INNOQ blog</a>.</p>

  </div>
  


  

  
    
        <script src="https://utteranc.es/client.js"
        repo="jacekbilski/jacekbilski.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
    


</article>


        </div>
        
    
<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
