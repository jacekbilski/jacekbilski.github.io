<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>testing on On Software Engineering</title>
    <link>https://www.bilski.tech/tags/testing/</link>
    <description>Recent content in testing on On Software Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Tue, 20 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bilski.tech/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring-less testing</title>
      <link>https://www.bilski.tech/posts/random/spring-less-testing/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/random/spring-less-testing/</guid>
      <description>Foreword This article was originally posted on INNOQ blog.
After it was published it caused a bit of a discussion on Twitter (even the creator of Spring Framework, Rod Johnson, replied) but also internally in the company (sorry, not public). The reason is, I believe, I&amp;rsquo;ve failed to clearly state my intention right from the start. My goal when writing this post always was to say: whenever you can write a test for your application without using Spring, you should do it exatly this way.</description>
    </item>
    
    <item>
      <title>Tests Granularity</title>
      <link>https://www.bilski.tech/posts/testing_primer/tests-granularity/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/testing_primer/tests-granularity/</guid>
      <description>Note, this post was originally published on INNOQ blog together with Torsten Mandry.
In two previous posts (see below) we discussed the benefits of automated tests and the properties of a good test. So far we were trying to avoid differentiating the tests in any way. This time we want to address one way how tests can be classified: tests granularity.
Previous posts:
 Why You Should Write Automated Tests Anatomy of a Good Test  What is granularity?</description>
    </item>
    
    <item>
      <title>Anatomy of a Good Test</title>
      <link>https://www.bilski.tech/posts/testing_primer/anatomy-of-a-good-test/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/testing_primer/anatomy-of-a-good-test/</guid>
      <description>Note, this post was originally published on INNOQ blog together with Torsten Mandry.
In our last post, we focused on why we should write tests and what value they provide. This time we will go far more technical and take a look at a single test. We will show what makes a test a good one and describe desired and unwanted properties. Interestingly enough, all those properties hold, no matter how isolated or integrated the test is.</description>
    </item>
    
    <item>
      <title>Why You Should Write Automated Tests</title>
      <link>https://www.bilski.tech/posts/testing_primer/why-you-should-write-automated-tests/</link>
      <pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/testing_primer/why-you-should-write-automated-tests/</guid>
      <description>Note, this post was originally published on INNOQ blog together with Torsten Mandry.
This blog post gives an overview of the most common benefits gained by writing automated tests. It starts in a place where most of the projects weâ€™ve seen so far are: tests are written as a last step of the development process. Then it shows additional benefits that could be gained if we all gave the tests a bit more focus and care.</description>
    </item>
    
    <item>
      <title>Iteration 7 - billing</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-7-billing/</link>
      <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-7-billing/</guid>
      <description>Welcome to the 7th iteration of WebCalc. Previously I scratched a surface of users and security in order to start working on billing. In retrospective, I don&amp;rsquo;t think I needed any user and Spring Security at all for billing to work, at least not in the first phase. Luckily, their introduction didn&amp;rsquo;t require much and should not actually hurt. The plan for this iteration is to get the billing as far as possible in terms of functionality.</description>
    </item>
    
    <item>
      <title>Iteration 6 - introducing users</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-6-introducing-users/</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-6-introducing-users/</guid>
      <description>Welcome to the 6th iteration of WebCalc. Previously I was dealing mostly with adding some more complex calculations. Like I mentioned there already, I think that I have already enough business logic to start moving into other areas like billing or user management. I also said that I&amp;rsquo;d be going into the unknown. Up until now, I had a rough idea of how to do things, now I don&amp;rsquo;t, I&amp;rsquo;ll be exploring a lot.</description>
    </item>
    
    <item>
      <title>Iteration 5 - more complex calculations</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-5-more-complex-calculations/</link>
      <pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-5-more-complex-calculations/</guid>
      <description>Welcome everyone to the fifth iteration of WebCalc. Previously I only managed to fix a few issues with the code and upgrade Java, Spring Boot and Gradle. This time I&amp;rsquo;ll get back to adding new functionalities and add a possibility to do more complex calculations like 1+2+3. To IDE then!
But first, let&amp;rsquo;s deal with some technical issues. One is upgrading Gradle to stable version 5.0. Having installed it locally on my machine, I can just call gradle wrapper --gradle-version=5.</description>
    </item>
    
    <item>
      <title>Iteration 4 - fixes only</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-4-fixes-only/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-4-fixes-only/</guid>
      <description>Welcome to the fourth iteration of WebCalc implementation. Previously I added multiplication and division as operations supported by my WebCalc. Especially the latter one forced me to add and change a few things in the code. By doing so I think I&amp;rsquo;ve made a mistake, that I&amp;rsquo;ll fix now.
The problem was to make Calculator stateful, it now remembers maxFractionDigits. If one user would set maxFractionDigits, all others would see that changed too.</description>
    </item>
    
    <item>
      <title>Testing is storytelling</title>
      <link>https://www.bilski.tech/posts/random/testing-is-storytelling/</link>
      <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/random/testing-is-storytelling/</guid>
      <description>While working with a customer, I recently saw a test, that looked like this: throw a big XML (&amp;gt;10kB) at a function, get another XML of similar size back and compare it with a pre-recorded one. The test is green if they&amp;rsquo;re equal. I guess, at the very minimum, it serves a purpose of detecting issues. The problem is that it cannot do much more.
What such a test is not providing are hints as to what the problem is when it fails.</description>
    </item>
    
    <item>
      <title>Iteration 3 - formatting and cleanup in calculator module</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-3-formatting-and-cleanup-in-calculator-module/</link>
      <pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-3-formatting-and-cleanup-in-calculator-module/</guid>
      <description>Welcome to the third iteration of WebCalc implementation. Previously I managed to get only basic operations working, namely addition and subtraction. This time I want to go further and add multiplication and division. Whereas multiplication should be pretty straightforward, I&amp;rsquo;m expecting issues with the division. Once I get these things working, I&amp;rsquo;ll see if I can improve the design of calculator itself and the tests. To IDE then.
Multiplication is, indeed, straightforward.</description>
    </item>
    
    <item>
      <title>Iteration 2 - actual calculations and modules separation</title>
      <link>https://www.bilski.tech/posts/webcalc/iteration-2-actual-calculations-and-modules-separation/</link>
      <pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/webcalc/iteration-2-actual-calculations-and-modules-separation/</guid>
      <description>Welcome to the second iteration of WebCalc implementation. Last time I managed only to get a basic construct working and only in a very crude way. Always returning &amp;ldquo;3&amp;rdquo; from a controller is hardly a proper solution. This time I&amp;rsquo;ll separate the app module from calculation one and then I&amp;rsquo;ll start digging into actual calculations.
But first, looking at Gradle files I&amp;rsquo;ve noticed a few unnecessary things. One thing is, that I&amp;rsquo;m specifying explicit versions for JUnit and REST-Assured, which, having Spring Boot, is not necessary.</description>
    </item>
    
  </channel>
</rss>
