<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>understanding on On Software Engineering</title>
    <link>https://www.bilski.tech/tags/understanding/</link>
    <description>Recent content in understanding on On Software Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Thu, 25 Oct 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.bilski.tech/tags/understanding/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Testing is storytelling</title>
      <link>https://www.bilski.tech/posts/testing-is-storytelling/</link>
      <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/testing-is-storytelling/</guid>
      <description>While working with a customer, I recently saw a test, that looked like this: throw a big XML (&amp;gt;10kB) at a function, get another XML of similar size back and compare it with a pre-recorded one. The test is green if they&amp;rsquo;re equal. I guess, at the very minimum, it serves a purpose of detecting issues. The problem is that it cannot do much more.
What such a test is not providing are hints as to what the problem is when it fails.</description>
    </item>
    
    <item>
      <title>Understanding decomposed</title>
      <link>https://www.bilski.tech/posts/understanding-decomposed/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/understanding-decomposed/</guid>
      <description>I previously wrote about simplicity and how it helps to understand software code. In that post, I already mentioned the use of concepts like set theory. Iâ€™d like to expand on this and show how to boost readability of code.
Despite what people might think, our main purpose as developers is not writing software, but solving problems. A code is just a means, not the goal. Nobody demands software just for the sake of it from a developer.</description>
    </item>
    
    <item>
      <title>Supporting understanding with simplicity</title>
      <link>https://www.bilski.tech/posts/supporting-understanding-with-simplicity/</link>
      <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.bilski.tech/posts/supporting-understanding-with-simplicity/</guid>
      <description>Some time ago, my colleague Joy Clark wrote about simplicity. I&amp;rsquo;ve also approached this topic once before. I&amp;rsquo;d like to follow up on both articles and show how simplicity can boost our understanding of software. I will also propose that we look at other disciplines to see if and how simplicity affects them. Maybe we can benefit from their experience.
What&amp;rsquo;s all the fuss about? Why do we even talk about simplicity?</description>
    </item>
    
  </channel>
</rss>